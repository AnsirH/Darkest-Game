---
alwaysApply: true
---

# DarkestLike 프로젝트 코딩 스타일 규칙

## 네이밍 컨벤션

### 클래스 및 타입
- **클래스명**: PascalCase 사용
  - 예: `DungeonDataManager`, `CharacterUnit`, `InDungeonSubsystem`

### 메서드 및 프로퍼티
- **메서드명**: PascalCase 사용
  - 예: `UpdateDungeonInfo()`, `SetCurrentMap()`, `EnterDungeon()`
- **프로퍼티명**: PascalCase 사용
  - 예: `CurrentMap`, `MoveSpeedX`, `CharacterUnits`

### 필드 및 변수
- **private 필드**: camelCase 사용
  - 예: `moveHorizontalInput`, `currentRoom`, `isInitialized`
- **public 필드**: PascalCase 사용 (최소화 권장)
- **지역 변수**: camelCase 사용

### 상수 및 열거형
- **상수**: UPPER_CASE 사용
  - 예: `SCENENAME_MAIN`, `PARAMETER_MOVESPEED`, `distanceBetweenRoom`
- **열거형**: PascalCase 사용
  - 예: `RoomType`, `TileType`, `CurrentLocation`

### 네임스페이스
- **네임스페이스**: PascalCase, 기능별 계층 구조
  - 예: `DarkestLike.Map`, `DarkestLike.InDungeon.BattleSystem`

## 코드 구조 및 스타일

### 클래스 구조 순서
```csharp
public class ExampleClass : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Component referenceComponent;
    
    [Header("Variables")]
    [SerializeField] private float configurableValue = 1.0f;
    
    // Events
    public event Action<DataType> OnEventTriggered;
    
    // Properties
    public float ReadOnlyProperty { get; private set; }
    public float ComputedProperty => someCalculation();
    
    // Unity Lifecycle Methods
    private void Awake() { }
    private void Start() { }
    private void Update() { }
    
    // Public Methods
    public void PublicMethod() { }
    
    // Private Methods
    private void PrivateMethod() { }
}
```

### Header 어트리뷰트 사용
- Inspector에서 설정되는 필드는 반드시 `[Header("References")]` 또는 `[Header("Variables")]` 사용
- 관련된 필드들을 그룹화하여 가독성 향상

### SerializeField 사용
- Inspector에서 설정해야 하는 private 필드는 `[SerializeField]` 사용
- public 필드는 최소화하고 프로퍼티 사용 권장

## Singleton 패턴

### 매니저 클래스는 Singleton 패턴 사용
```csharp
public class ManagerClass : Singleton<ManagerClass>
{
    protected override void Awake()
    {
        base.Awake();
        // 초기화 로직
    }
}
```

### 싱글톤 접근
- 싱글톤 인스턴스 접근 시 `Inst` 프로퍼티 사용
  - 예: `DungeonDataManager.Inst`, `InDungeonManager.Inst`

## 서브시스템 아키텍처

### 서브시스템 베이스 클래스 상속
```csharp
public class CustomSubsystem : InDungeonSubsystem
{
    protected override void OnInitialize()
    {
        // 초기화 로직
    }
    
    public override void Shutdown()
    {
        base.Shutdown();
        // 정리 로직
    }
}
```

## 이벤트 시스템

### 이벤트 선언 및 사용
```csharp
// 이벤트 선언
public event Action<DataType> OnDataChanged;

// 이벤트 호출
OnDataChanged?.Invoke(data);

// 이벤트 구독
Manager.Inst.OnDataChanged += HandleDataChanged;

// 이벤트 해제 (중요: 메모리 누수 방지)
Manager.Inst.OnDataChanged -= HandleDataChanged;
```

## 주석 및 문서화

### XML 문서 주석
- 공개 API에는 XML 문서 주석 사용
```csharp
/// <summary>
/// 맵 데이터를 기반으로 던전 맵을 생성합니다.
/// </summary>
/// <param name="mapData">맵 생성에 사용할 데이터</param>
/// <returns>생성된 맵 객체</returns>
public static MapData GenerateMap(MapSOData mapData)
```

### 인라인 주석
- 복잡한 로직이나 비즈니스 규칙에 한글 주석 사용
```csharp
// 던전은 첫 번째 맵을 기본적으로 선택한다.
selectedMap = new() { MapGenerator.GenerateMap(data.MapDatas[0]) };
```

## 데이터 시스템

### ScriptableObject 사용
- 설정 데이터는 ScriptableObject 사용
- `[CreateAssetMenu]` 어트리뷰트로 에디터 메뉴 추가

### 런타임 데이터 클래스
- `[System.Serializable]` 어트리뷰트 사용
- 생성자에서 초기화 로직 구현

## 코루틴 및 비동기 처리

### 코루틴 네이밍
- 코루틴 메서드는 `Coroutine` 접미사 사용
  - 예: `EnterRoomCoroutine()`, `FadeOutCoroutine()`

### async/await 사용
- UniTask 사용 시 `UniTaskVoid` 반환 타입 사용
  - 예: `public async UniTaskVoid LoadScene()`

## 오류 처리

### null 체크
- 참조 타입 사용 전 null 체크
```csharp
if (component == null) component = GetComponent<Component>();
```

### 예외 처리
- 예상치 못한 상황에 대한 적절한 예외 처리
- Debug.LogWarning 사용하여 개발자에게 알림

## 성능 고려사항

### 프로퍼티 사용
- 계산이 필요한 값은 프로퍼티로 구현
- 캐싱이 필요한 경우 private 필드와 함께 사용

### 리스트 및 컬렉션
- `List<T>` 초기화 시 `new()` 사용
- 불필요한 할당 최소화

이 규칙들을 준수하여 코드의 일관성과 가독성을 유지하세요.

## 코드 수정 정책

### 절대적인 규칙
- **사용자가 명시적으로 "수정해줘", "구현해줘", "작성해줘" 등의 수정 요청을 하기 전까지는 절대 코드를 수정하지 마세요.**
- 코드 분석, 파악, 이해 요청에는 분석 결과만 제공하고 수정하지 마세요.
- 사용자가 "코드 읽어봐", "파악해봐", "분석해봐"라고 하면 코드를 읽고 분석 결과만 제공하세요.

### 수정 허용 조건
- 사용자가 명확한 수정 지시를 했을 때만 코드를 수정하세요.
- 예시: "수정해줘", "구현해줘", "작성해줘", "개선해줘", "추가해줘", "삭제해줘"

### 분석 vs 수정 구분
- **분석 요청**: 코드 읽기 → 분석 결과 제공 → 수정하지 않음
- **수정 요청**: 코드 읽기 → 수정 작업 진행

### 코드 수정 범위
- 사용자가 지시한 구현 범위를 미리 파악하여 규정하고 이를 벗어나 과도하게 구현 및 수정하지 마세요.

### 코드 수정 절차
- 코드를 수정할 때는 사용자의 지시를 기반으로 코드 수정 계획을 수립하고, 계획에 맞게 절차적으로 수정하세요.

이 규칙을 반드시 준수하세요.